add a CI “plan guard” that fails if the planner stops using the composite index

Goal: add a tiny script that runs EXPLAIN (ANALYZE, BUFFERS) for the page-2 cursor predicate and asserts:

uses idx_users_org_created_id

no separate Sort

execution time is reasonable (configurable threshold)

Do exactly this (no app code changes):

Create a script that runs the plan and hard-asserts:

# apps/bff/tools/plan-employees.ts

import { Client } from 'pg';

const THRESHOLD_MS = Number(process.env.PLAN_MAX_MS ?? 25); // tweakable
const INDEX_NAME = 'idx_users_org_created_id';

(async () => {
  const client = new Client({ connectionString: process.env.DATABASE_URL });
  await client.connect();

  // 1) pick an org and a stable cursor (6th row) to simulate page-2
  const { rows: orgs } = await client.query(`select id from organizations order by created_at asc limit 1`);
  if (!orgs.length) throw new Error('No organizations found');
  const orgId = orgs[0].id;

  const { rows: cursor } = await client.query(`
    select created_at as "createdAt", id
    from users
    where organization_id = $1
    order by created_at asc, id asc
    offset 5 limit 1
  `, [orgId]);
  if (!cursor.length) throw new Error('Not enough users to compute a cursor');

  const { createdAt, id } = cursor[0];

  // 2) explain analyze the page-2 query
  const { rows: planRows } = await client.query(`
    EXPLAIN (ANALYZE, BUFFERS)
    SELECT id, email
    FROM users
    WHERE organization_id = $1
      AND (created_at, id) > ($2::timestamp, $3::uuid)
    ORDER BY created_at ASC, id ASC
    LIMIT 101;
  `, [orgId, createdAt, id]);

  const planText = planRows.map(r => r['QUERY PLAN']).join('\n');

  // 3) assertions
  const usesIndex = /Index (Only )?Scan .*idx_users_org_created_id/.test(planText);
  const hasSort = /\bSort\b/.test(planText);
  const timeMatch = planText.match(/Execution Time:\s+([\d.]+)\s+ms/);
  const timeMs = timeMatch ? Number(timeMatch[1]) : NaN;

  const failures: string[] = [];
  if (!usesIndex) failures.push('Planner did not use idx_users_org_created_id');
  if (hasSort) failures.push('Planner added a Sort (ordering not satisfied by index)');
  if (!Number.isFinite(timeMs)) failures.push('Could not parse execution time');
  else if (timeMs > THRESHOLD_MS) failures.push(`Execution time ${timeMs}ms > ${THRESHOLD_MS}ms`);

  if (failures.length) {
    console.error('--- PLAN GUARD FAIL ---');
    console.error(planText);
    console.error('Failures:', failures);
    process.exit(1);
  } else {
    console.log('INDEX_OK ✅  NO_SORT ✅  TIME_OK ✅', `(Execution ${timeMs}ms)`);
  }

  await client.end();
})().catch(err => {
  console.error(err);
  process.exit(1);
});


Add an Nx target (or npm script) to run it:

If you have a tools/global area already, wire it there; otherwise add to apps/bff/project.json:

{
  "targets": {
    "plan:check": {
      "executor": "nx:run-commands",
      "options": {
        "command": "ts-node --transpile-only apps/bff/tools/plan-employees.ts",
        "env": {
          "PLAN_MAX_MS": "25"
        }
      }
    }
  }
}


(If ts-node isn’t installed, use node -r ts-node/register or precompile with tsc and run node on the emitted JS.)

Run it three times to check stability:

DATABASE_URL=... npx nx run bff:plan:check && \
DATABASE_URL=... npx nx run bff:plan:check && \
DATABASE_URL=... npx nx run bff:plan:check


Definition of Done

Command prints something like:
INDEX_OK ✅ NO_SORT ✅ TIME_OK ✅ (Execution 0.7ms)

Fails the build if the planner regresses (no index, sort present, or time > threshold).

No mutations to app code or migrations.