Execute this EXACT task. Do not touch anything beyond what’s listed.
If any command fails, PRINT the error and STOP. Do not “fix” or scaffold.

GOAL
Enable writes on approval:

POST /directory/import/session/approve will decode the session token and APPLY changes:
• create or update users (firstName, lastName, displayName) — email+orgId is the key
• create missing departments in org_units (type='department')
• ensure user membership in that department via org_membership

Return a write report (counts + per-row results).

Ignore unsupported fields (jobTitle, phone, etc.) and return them under ignoredFields per record.

TOUCH ONLY
apps/bff/src/modules/identity/identity.repository.ts
apps/bff/src/modules/directory/directory.service.ts
apps/bff/src/modules/directory/directory.controller.ts

CHANGES
// apps/bff/src/modules/identity/identity.repository.ts
// Append the following methods (keep existing imports and class; reuse existing db, users, etc.)
import { orgUnits } from '../../../services/identity/src/db/schema/org_units';
import { orgMembership } from '../../../services/identity/src/db/schema/org_membership';
import { and, eq } from 'drizzle-orm';

export class IdentityRepository {
// ...keep existing code...

async createUser(orgId: string, email: string, firstName: string, lastName: string) {
const displayName = [firstName, lastName].filter(Boolean).join(' ').trim();
const [row] = await db.insert(users).values({
organizationId: orgId,
email,
firstName,
lastName,
displayName,
isActive: true,
}).returning();
return row;
}

async updateUserNames(userId: string, firstName: string|null|undefined, lastName: string|null|undefined) {
const patch: any = {};
if (firstName != null) patch.firstName = firstName;
if (lastName != null) patch.lastName = lastName;
if ('firstName' in patch || 'lastName' in patch) {
const displayName = [patch.firstName, patch.lastName].filter(Boolean).join(' ').trim();
if (displayName) patch.displayName = displayName;
}
if (Object.keys(patch).length === 0) return null;
const [row] = await db.update(users).set(patch).where(eq(users.id, userId)).returning();
return row;
}

async findOrCreateDepartment(orgId: string, name: string) {
const trimmed = name.trim();
if (!trimmed) return null;
const existing = await db.select().from(orgUnits)
.where(and(eq(orgUnits.organizationId, orgId), eq(orgUnits.type, 'department'), eq(orgUnits.name, trimmed)))
.limit(1);
if (existing[0]) return existing[0];
const [created] = await db.insert(orgUnits).values({
organizationId: orgId,
type: 'department',
name: trimmed,
}).returning();
return created;
}

async ensureMembership(userId: string, orgUnitId: string) {
const existing = await db.select().from(orgMembership)
.where(and(eq(orgMembership.userId, userId), eq(orgMembership.orgUnitId, orgUnitId)))
.limit(1);
if (existing[0]) return existing[0];
const [created] = await db.insert(orgMembership).values({
userId, orgUnitId
}).returning();
return created;
}
}

// apps/bff/src/modules/directory/directory.service.ts
// Add an applyImportSession() method that verifies token and performs writes supported by schema.
import { BadRequestException, Inject, Injectable } from '@nestjs/common';
import { IdentityRepository } from '../identity/identity.repository';
// NOTE: uses verifyToken() helper already added in previous slice

type ApplyResultRow = {
email: string|null;
action: 'created'|'updated'|'skipped'|'error';
userId?: string;
department?: string|null;
departmentCreated?: boolean;
membershipLinked?: boolean;
ignoredFields?: string[];
message?: string;
};
type ApplyReport = {
createdUsers: number;
updatedUsers: number;
skipped: number;
errors: number;
departmentsCreated: number;
membershipsLinked: number;
rows: ApplyResultRow[];
};

export class DirectoryService {
// ...keep existing constructor, commitPlan(), createImportSession(), previewImportSession(), etc.

async applyImportSession(token: string, orgIdFromJwt: string): Promise<ApplyReport> {
let payload: any;
try {
payload = verifyToken(token, process.env.JWT_SECRET || 'dev-secret');
} catch (e: any) {
throw new BadRequestException(Invalid or expired session token: ${e?.message || 'unknown'});
}
if (!payload?.orgId || payload.orgId !== orgIdFromJwt) {
throw new BadRequestException('Session/org mismatch.');
}

php
Copy
Edit
const rows: ApplyResultRow[] = [];
let createdUsers = 0, updatedUsers = 0, skipped = 0, errors = 0, departmentsCreated = 0, membershipsLinked = 0;

for (const rec of payload.records as any[]) {
  const email = rec?.incoming?.email ?? null;
  const deptName = rec?.incoming?.department ?? null;

  const ignoredFields: string[] = [];
  // These fields are not in the users schema yet; mark as ignored:
  ['jobTitle','location','employeeId','startDate','birthDate','nationality','gender','phone','managerEmail']
    .forEach(f => { if (rec?.incoming?.[f] != null) ignoredFields.push(f); });

  try {
    if (!email || !rec?.action) {
      skipped++; rows.push({ email, action: 'skipped', ignoredFields, message: 'Missing email or action' });
      continue;
    }

    // Determine create/update from planner’s decision.
    if (rec.action === 'create') {
      const user = await this.identity.findUserByEmailOrg(email, payload.orgId);
      const firstName = rec.incoming?.givenName ?? null;
      const lastName  = rec.incoming?.familyName ?? null;

      const u = user ?? await this.identity.createUser(payload.orgId, email, firstName || '', lastName || '');
      if (!user) createdUsers++; else updatedUsers++; // if user existed, treat as update via name sync below

      if (user) {
        await this.identity.updateUserNames(user.id, firstName, lastName);
      }

      let departmentCreated = false;
      let membershipLinkedFlag = false;
      if (deptName) {
        const dept = await this.identity.findOrCreateDepartment(payload.orgId, deptName);
        if (dept) {
          if (dept.name?.trim() === deptName.trim()) {
            // we can infer creation by re-fetch + equality; simpler: if not found earlier, it was created
          }
          // naive heuristic: if membership didn’t exist, ensureMembership will create one
          const m = await this.identity.ensureMembership(u.id, dept.id);
          membershipLinkedFlag = !!m;
          // we can’t perfectly know if dept was just created; count by comparing against planner’s overview.newDepartments if needed.
        }
      }

      rows.push({
        email, action: user ? 'updated' : 'created',
        userId: (user ? user.id : u.id),
        department: deptName,
        membershipLinked: membershipLinkedFlag,
        ignoredFields
      });
    } else if (rec.action === 'update') {
      const user = await this.identity.findUserByEmailOrg(email, payload.orgId);
      if (!user) {
        // Safety: if planner said update but user disappeared, create now.
        const firstName = rec.incoming?.givenName ?? '';
        const lastName  = rec.incoming?.familyName ?? '';
        const u = await this.identity.createUser(payload.orgId, email, firstName, lastName);
        createdUsers++;
        let membershipLinkedFlag = false;
        if (deptName) {
          const dept = await this.identity.findOrCreateDepartment(payload.orgId, deptName);
          if (dept) {
            await this.identity.ensureMembership(u.id, dept.id);
            membershipLinkedFlag = true;
          }
        }
        rows.push({ email, action: 'created', userId: u.id, department: deptName, membershipLinked: membershipLinkedFlag, ignoredFields });
        continue;
      }

      const firstName = rec.incoming?.givenName ?? null;
      const lastName  = rec.incoming?.familyName ?? null;
      await this.identity.updateUserNames(user.id, firstName, lastName);
      updatedUsers++;

      let membershipLinkedFlag = false;
      if (deptName) {
        const dept = await this.identity.findOrCreateDepartment(payload.orgId, deptName);
        if (dept) {
          await this.identity.ensureMembership(user.id, dept.id);
          membershipLinkedFlag = true;
        }
      }

      rows.push({ email, action: 'updated', userId: user.id, department: deptName, membershipLinked: membershipLinkedFlag, ignoredFields });
    } else {
      skipped++; rows.push({ email, action: 'skipped', department: deptName, ignoredFields });
    }
  } catch (e: any) {
    errors++;
    rows.push({ email, action: 'error', department: deptName, ignoredFields, message: e?.message || 'unknown error' });
  }
}

// departmentsCreated is hard to know precisely without diffing; approximate with overview.newDepartments length if present
if (Array.isArray(payload?.overview?.newDepartments)) {
  departmentsCreated = payload.overview.newDepartments.length;
}

return {
  createdUsers, updatedUsers, skipped, errors,
  departmentsCreated,
  membershipsLinked,
  rows,
};
}
}

// apps/bff/src/modules/directory/directory.controller.ts
// Wire the approve endpoint to applyImportSession()
import { ImportSessionApproveDto } from './dtos/import-session.dto';
import { BadRequestException } from '@nestjs/common';

export class DirectoryController {
// ...keep existing constructor + endpoints...

@UseGuards(JwtAuthGuard)
@Post('import/session/approve')
async approve(@Body() dto: ImportSessionApproveDto, @Req() req: any) {
if (!dto?.token) throw new BadRequestException('token is required');
const orgId = req.user?.orgId;
return this.svc.applyImportSession(dto.token, orgId);
}
}

RUN & PRINT

Build
npx nx build bff && echo "=== BUILD OK ==="

Auth token
ORG_ID=$(curl -s 'http://localhost:5000/orgs?limit=1' | grep -o '"id":"[^"]"' | head -1 | cut -d'"' -f4)
LOGIN=$(curl -s -X POST http://localhost:5000/auth/login -H 'content-type: application/json' -d "{"orgId":"$ORG_ID","email":"csvdemo@example.com"}")
ACCESS=$(echo "$LOGIN" | grep -o '"accessToken":"[^"]"' | cut -d'"' -f4)
echo "ORG_ID: $ORG_ID"; echo "ACCESS_LEN=$(echo -n $ACCESS | wc -c)"

1) Create a session (same CSV used earlier)
SESSION=$(curl -s -X POST http://localhost:5000/directory/import/session
-H "content-type: application/json" -H "Authorization: Bearer $ACCESS"
-d @- <<'JSON'
{"csv":"email,givenName,familyName,department\nalex@demo.com,Alex,Stone,Engineering\nmaria@demo.com,Maria,Gomez,Finance"}
JSON
)
TOKEN=$(echo "$SESSION" | grep -o '"token":"[^"]*"' | cut -d'"' -f4)
echo "SESSION_TOKEN_LEN=$(echo -n "$TOKEN" | wc -c)"

2) Preview session
curl -s "http://localhost:5000/directory/import/session/preview?token=$TOKEN"
-H "Authorization: Bearer $ACCESS" | python3 -m json.tool | head -60

3) Approve (APPLY WRITES)
curl -s -X POST http://localhost:5000/directory/import/session/approve
-H "content-type: application/json" -H "Authorization: Bearer $ACCESS"
-d "{"token":"$TOKEN"}" | python3 -m json.tool | head -160

4) Sanity: create same session again and approve — should skew to updates/skips (idempotent-ish)
SESSION2=$(curl -s -X POST http://localhost:5000/directory/import/session
-H "content-type: application/json" -H "Authorization: Bearer $ACCESS"
-d @- <<'JSON'
{"csv":"email,givenName,familyName,department\nalex@demo.com,Alex,Stone,Engineering\nmaria@demo.com,Maria,Gomez,Finance"}
JSON
)
TOKEN2=$(echo "$SESSION2" | grep -o '"token":"[^"]*"' | cut -d'"' -f4)
curl -s -X POST http://localhost:5000/directory/import/session/approve
-H "content-type: application/json" -H "Authorization: Bearer $ACCESS"
-d "{"token":"$TOKEN2"}" | python3 -m json.tool | head -160

5) Ask roadmap/regressions
echo "=== STATUS QUESTION ==="
echo "Replit, confirm: After enabling approval writes (users + departments + memberships), where are we vs the roadmap, and any regression in previous features?"

STOP.